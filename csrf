CSRF works because:

The browser automatically sends session cookies with requests ‚Äî even if the request was triggered by a malicious site.

The attacker doesn‚Äôt steal anything.
They trick the browser into acting.

Think:
‚Äúuse the victim as a proxy‚Äù


How does CSRF work?
For a CSRF attack to be possible, three key conditions must be in place:

A relevant action. There is an action within the application that the attacker has a reason to induce. This might be a privileged action (such as modifying permissions for other users) or any action on user-specific data (such as changing the user's own password).
Cookie-based session handling. Performing the action involves issuing one or more HTTP requests, and the application relies solely on session cookies to identify the user who has made the requests. There is no other mechanism in place for tracking sessions or validating user requests.
No unpredictable request parameters. The requests that perform the action do not contain any parameters whose values the attacker cannot determine or guess. For example, when causing a user to change their password, the function is not vulnerable if an attacker needs to know the value of the existing password.

Cookie-Based Session Auth
The app must rely on:

Cookie: session=abc123


Browser auto-sends this cookie whenever a request goes to that domain.

That‚Äôs the core exploit point.

If the app instead required:

custom auth header

API token not auto-sent

re-enter password

OTP confirmation

CSRF becomes much harder or impossible.

 Condition 3 ‚Äî No Unpredictable Parameters

Attacker must be able to fully craft the request.

If request is:

POST /change-password
old_password=???
new_password=123


Attacker doesn‚Äôt know old_password ‚Üí attack fails.

But if request is:

POST /change-email
email=attacker@mail.com
so basically csrf is like tricking a logges in browser  to do malcious things this is because browser stores all the cookies and it can make th erequests

so for example there an web application of a bank site that does something for updating the passwoed this is the http request made by the website

POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com


Why CSRF Tokens Kill This Attack

Server adds:

csrf_token = random_unpredictable_value


Request must include it.

Attacker cannot read victim‚Äôs page ‚Üí cannot get token ‚Üí attack fails.

Game over.

<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>

Manually creating the HTML needed for a CSRF exploit can be cumbersome, particularly where the desired request contains a large number of parameters, or there are other quirks in the request. The easiest way to construct a CSRF exploit is using the CSRF PoC generator that is built in to Burp Suite Professiona

Select a request anywhere in Burp Suite Professional that you want to test or exploit.
From the right-click context menu, select Engagement tools / Generate CSRF PoC.
Burp Suite will generate some HTML that will trigger the selected request (minus cookies, which will be added automatically by the victim's browser).
You can tweak various options in the CSRF PoC generator to fine-tune aspects of the attack. You might need to do this in some unusual situations to deal with quirky features of requests.
Copy the generated HTML into a web page, view it in a browser that is logged in to the vulnerable website, and test whether the intended request is issued successfully and the desired action occurs.


so i did a lab where i crafted an malcious html code that changes the email address of the user so what i did was first captured how the email request for change looked and took that changed the email address. where i uploaded it to the server where it visits the page so that the victim goes to the site and his mail was changed


so my question is that how does get does this?
so bascially get is like designed when this endpoint is called call this

GET /id

so when this endpoint is called GET/update?email 

Step-by-Step: How GET Works (Normally)

When you type a URL in the browser:

https://site.com/profile


Browser sends:

GET /profile


Server returns data ‚Üí page loads.

That‚Äôs the normal read-only use.

üí• Now ‚Äî Misused GET Endpoint

Imagine the developer wrote backend code like this:

GET /change-email?new=attacker@mail.com


And the server logic says:

when this route is hit ‚Üí update user email

That‚Äôs bad design ‚Äî but technically possible.

So just visiting this URL triggers the change.

üî¨ What Actually Happens in the Browser

Victim is logged into:

site.com


Cookie stored:

session=abc123

Attacker sends this in a page/email:
<img src="https://site.com/change-email?new=attacker@mail.com">

When victim opens the page:

Browser tries to load the image ‚Üí which means:

GET /change-email?new=attacker@mail.com
Host: site.com
Cookie: session=abc123

GET request is triggered by:

visiting a link

loading an image

iframe

script tag

CSS url()

prefetching

bots

previews

Nowadays, successfully finding and exploiting CSRF vulnerabilities often involves bypassing anti-CSRF measures deployed by the target website, the victim's browser, or both. The most common defenses you'll encounter are as follows:

CSRF tokens - A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When attempting to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token in the request. This makes it very difficult for an attacker to construct a valid request on behalf of the victim.

SameSite cookies - SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. As requests to perform sensitive actions typically require an authenticated session cookie, the appropriate SameSite restrictions may prevent an attacker from triggering these actions cross-site. Since 2021, Chrome enforces Lax SameSite restrictions by default. As this is the proposed standard, we expect other major browsers to adopt this behavior in future.

Referer-based validation - Some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain. This is generally less effective than CSRF token validation.


A CSRF token is a unique, secret, and unpredictable value that is generated by the server-side application and shared with the client. When issuing a request to perform a sensitive action, such as submitting a form, the client must include the correct CSRF token. Otherwise, the server will refuse to perform the requested action.

A common way to share CSRF tokens with the client is to include them as a hidden parameter in an HTML form, for example:

<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>

es ‚Äî if you truly have your friend‚Äôs valid CSRF token and their authenticated session cookie, you can forge the protected request. At that point, CSRF defense is bypassed. But getting both is the hard part, and if you can, something else is already broken.


Why Attackers Normally Can‚Äôt Do This

In a real CSRF attack model:

attacker is on another origin (evil site)

browser blocks reading victim site content (Same Origin Policy)

CSRF token is inside victim page/form/header

attacker can trigger requests but cannot read token

So they can‚Äôt include the correct token value.

Common flaws in CSRF token validation
Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.
this is the first lab
In this situation, the attacker can switch to the GET method to bypass the validation and deliver a CSRF attack:

GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

Lab: CSRF where token validation depends on request method
The Bug: CSRF Token Checked Only for POST

Some apps implement CSRF protection like this (bad logic):

if request.method == POST:
    check_csrf_token()
else:
    skip_check()


Developer assumption:

‚ÄúAll dangerous actions use POST anyway.‚Äù

Reality:

Routes often accept multiple methods ‚Äî including GET ‚Äî unless explicitly restricted.

That gap = bypass.

‚öôÔ∏è What Happens in This Vulnerable Setup

Suppose endpoint exists:

POST /email/change


and it validates CSRF token correctly.

But backend also allows:

GET /email/change?email=...


and does not validate CSRF token for GET.

Now attacker just switches method.

üí• Attack Flow

Victim is logged in:

Cookie: session=ABC123


Attacker embeds:

<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">


Browser sends:

GET /email/change?email=pwned@evil-user.net
Cookie: session=ABC123


Server behavior:

sees valid session

skips CSRF check (because GET)

executes email change

Attack succeeds

Validation of CSRF token depends on token being present
Some applications correctly validate the token when it is present but skip the validation if the token is omitted.

In this situation, the attacker can remove the entire parameter containing the token (not just its value) to bypass the validation and deliver a CSRF attack:
this is a logical flaw but worth trying it

CSRF token is not tied to the user session
Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.

In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack.

CSRF token is not tied to the user session
Some applications do not validate that the token belongs to the same session as the user who is making the request. Instead, the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.

In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack.


CSRF token is a session itself in that case i can just make a re

In a variation on the preceding vulnerability, some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together:

POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com

How an Attacker Ends Up Controlling Set-Cookie

Subdomain Takeover
xss 
header injection


CSRF token is simply duplicated in a cookie



What Is ‚ÄúDouble Submit Cookie‚Äù CSRF Protection?

Instead of storing CSRF tokens on the server, the app does this:

1Ô∏è‚É£ Generate a CSRF token
2Ô∏è‚É£ Send it to the browser as a cookie
3Ô∏è‚É£ Also require the same token in the request body (or header)
4Ô∏è‚É£ On submit ‚Üí server checks they match

No server-side token storage. No session binding.

That‚Äôs why it‚Äôs called double submit ‚Äî same value submitted twice.

üîç Your Example ‚Äî What It Shows

Request:

POST /email/change

Cookie:
session=1DQGdzYb...
csrf=R8ov2YBfTY...

Body:
csrf=R8ov2YBfTY...
email=wiener@normal-user.com


Server validation logic:

if request.body.csrf == request.cookie.csrf:
    accept
else:
    reject


<html>
<body>

<form action="https://0a03004104aa702a80e303f700ea00b8.web-security-academy.net/my-account/change-email" method="POST">
  <input type="hidden" name="email" value="pwn@evil.com">
  <input type="hidden" name="csrf" value="attack123">
</form>

<img src="https://0a03004104aa702a80e303f700ea00b8.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=attack123;%20SameSite=None;%20Secure"
     onerror="document.forms[0].submit()">

</body>
</html>

to do's i want to solve the labs


Bypassing SameSite cookie restrictions
so samesite cookie restriction is like allowing the request only from the request origin not from any cross site

Since 2021, Chrome applies Lax SameSite restrictions by default if the website that issues the cookie doesn't explicitly set its own restriction level. This is a proposed standard, and we expect other major browsers to adopt this behavior in the future. As a result, it's essential to have solid grasp of how these restrictions work, as well as how they can potentially be bypassed, in order to thoroughly test for cross-site attack vectors.
In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like .com or .net, plus one additional level of the domain name. This is often referred to as the TLD+1.
When determining whether a request is same-site or not, the URL scheme is also taken into consideration. This means that a link from http://app.example.com to https://app.example.com is treated as cross-site by most browsers.


The difference between a site and an origin is their scope; a site encompasses multiple domain names, whereas an origin only includes one. Although they're closely related, it's important not to use the terms interchangeably as conflating the two can have serious security implications.

Two URLs are considered to have the same origin if they share the exact same scheme, domain name, and port. Although note that the port is often inferred from the scheme.

(origin) = (scheme, host, port)
before same site or same orgin policy the browser allowed the website to do cross origin requests to the site 

all major browsers currently support the following SameSite restriction levels:
. As these requests typically require a cookie associated with the victim's authenticated session, the attack will fail if the browser doesn't include this.

Strict
Lax
None

to apply the same site policy the site just has to apply it in the set cookie header with same site policy on like strict lax or none

by default google 

If the website issuing the cookie doesn't explicitly set a SameSite attribute, Chrome automatically applies Lax restrictions by default. This means that the cookie is only sent in cross-site requests that meet specific criteria, even though the developers never configured this behavior. As this is a proposed new standard, we expect other major browsers to adopt this behavior in future.

If a cookie is set with the SameSite=Strict attribute, browsers will not send it in any cross-site requests. In simple terms, this means that if the target site for the request does not match the site currently shown in the browser's address bar, it will not include the cookie.

This is recommended when setting cookies that enable the bearer to modify data or perform other sensitive actions, such as accessing specific pages that are only available to authenticated users.

Although this is the most secure option, it can negatively impact the user experience in cases where cross-site functionality is desirable.

Lax is where the site allows cors under some conditons

1)the site should use the get method

2) User clicks a link ‚Üí goes to another site

User is redirected ‚Üí browser loads new page

User types URL ‚Üí page loads

If a cookie is set with the SameSite=None attribute, this effectively disables SameSite restrictions altogether, regardless of the browser. As a result, browsers will send this cookie in all requests to the site that issued it, even those that were triggered by completely unrelated third-party sites.

With the exception of Chrome, this is the default behavior used by major browsers if no SameSite attribute is provided when setting the cookie.

There are legitimate reasons for disabling SameSite, such as when the cookie is intended to be used from a third-party context and doesn't grant the bearer access to any sensitive data or functionality. Tracking cookies are a typical example.


Set-Cookie: trackingId=0F8tgdOhi9ynR1M9wa3ODa; SameSite=None; Secure
so most of the sites can disable the samesite option and When setting a cookie with SameSite=None, the website must also include the Secure attribute, which ensures that the cookie is only sent in encrypted messages over HTTPS. Otherwise, browsers will reject the cookie and it won't be set.
We can bypass the restriction of same-site restriction:lax by abusing the use of the get and page avigation

As lax only allows get and resource sharing from its own sites
we can 

<script>
    document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';
</script>
what it does is that it just sets a location so when the user vistis the evil.com this gets executed as it belives it comes from the same origin

so we assume that the endpont is get /makepayment

so on a whole how does the same site actually does is that whether to set the cookie or not based upon the policy like is the method post then dont send cookie , so now your thing 
POST /transfer
Body: _method=GET
so the request goes to the backend and in backend there is something known as framework to had

_method what it does is that it just does something which is not present in the http header

Request arrives at server.

Framework middleware runs before routing.

Some frameworks (Symfony, Laravel, Rails, etc.) support method override.

Middleware logic:

if POST and body contains _method:
    effective_method = body["_method"]


Now framework routing sees:

GET /makepayment
so we are just absuing the method override function like to do something vulnerable even though get is send

The browser sends cookies because it sees a GET.
The backend changes behavior because it sees the override parameter.
Two different layers. No magic ‚Äî just misplaced trust.

Let‚Äôs walk it tight.

üß≠ What the browser sees

Attacker triggers this from another site:

https://vulnerable.com/transfer?_method=POST&amount=1000&to=hacker


From the browser‚Äôs point of view:

Method = GET

Type = top-level navigation

Cross-site = yes

SameSite=Lax rule says:

Top-level cross-site GET ‚Üí cookies allowed

So:

Cookie: session=abc123   ‚úÖ sent

